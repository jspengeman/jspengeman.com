---
layout: post
title: Being a Pragmatic Programmer - Part 2
permalink: /being-a-pragmatic-programmer-part-2
---

Continuing on my thoughts on being a pragmatic programmer I discuss design by contract and assertive programming. In conjunction with that, I spend a some time discussing problem solving. Next, I dive into my experiences with wizard code, a topic we cover more in detail later on. Continuing, I describe how design to test is more valuable than trying to strap tests on when all is said and done. The last topic I spend some time on is the concept of how orthogonal software components should be (or shouldn't). If you didn't read the [previous post](/being-a-pragmatic-programmer-part-1) in this series I recommend doing so but it is not required.

### Design By Contract and Assertive Programming
Design by contract and assertive programming seem to be very orthogonal issues to me. I discuss design by contract in this [post](/design-by-contract-with-react-and-redux) but for those that haven't read it; design by contract is essentially contractual obligations that software components __must__ uphold certain pre and post conditions. I firmly believe that you will see an increase in maintainability if you document a contract for every piece of code you write. In conjunction with that, the maintainability of your product will sky rocket if you are being an assertive programmer with regards to your contract.

Why should you even bother documenting software contracts? Imagine you call a function to calculate the square root of a number, what does that function do if a negative number is passed in as an argument? Does it return an imaginary number or does it throw an error? In the parameter level documentation if would be worth documenting the behavior of this case. Further, it is worth documenting all edge cases of all software components you write. Does this function operate on negative values, what about null values, does it throw an error I need to catch? All of the answers to these question can make up a contract that can be documented that you can refer to when you need to know what behavior you need to be able to handle when you call the function in question.

We alluded to it a bit earlier but it is important to enforce contracts. Enforcing your contract for your software component can be relativity simple. If your contract states something like `throws an Error if parameter number is negative` then enforcing that contract is easy, the first thing your function should do is check if `number` is negative or not, if it is negative then it should throw an error. It is up to you what the result of your edge cases will be but they should be one hundred percent consistent with the contract you documented. Perhaps you thrown an exception or return some well know default value. The practice of assertive programming makes your code more maintainable because people calling your code know exactly what types of return values or side affects they should be able to handle.

### Ensure You're Solving the Right Problem
As a software developer it is your job to solve problems. If something feels too challenging or even impossible it is probably because you are solving the wrong problem. Take a step back and consider that there may be another way to solve the current problem. Are you thinking inside or outside of the box? Where is the box exactly defined? A problem may seem difficult because you were unaware of the boundaries of the box. Perhaps, you did not realize that a library was capable of solving a specific problem for you so you rolled your own solution and it was challenging or perhaps, you were unaware that the problem occurs so frequently that someone on your team has already solved it for you. Always consider that a problem may not be impossible but that you may be solving the wrong problem.

Often we find ourselves so far removed from our domain, solving a problem that is a sub-problem of our current task that it causes us to ask for help on questions that don't need to be solved. Imagine you are trying to solve problem X but to solve problem X you need to do Y, although, you get stuck solving Y so you ask for help with regards to problem Y. This is referred to as an [XY problem](https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem). Problem Y was never the problem you needed to solve. 

When *asking* a question I would recommend phrasing your question in a way that mentions both X and Y. One option might be, "I am trying to solve X, I have tried Y but it is not working, any ideas?" This way, you expose the person you are requesting help from to the source problem and the way you are trying to solve it, either they know a better way to solve it or they can help you figure out why what you are trying is not working. When *answering* questions the first thing I would recommend asking would be a clarifying question to ensure you are helping them with the right question. An option for that might look like the following, "What exactly are we trying to achieve by doing X?" They may respond by telling you that they are actually trying to do Y or they clarify their question further.  

### Beware of Evil Wizards
I am a big fan of libraries and frameworks if they solve the right problem. Often if you don't end up using a framework you will end up writing your own (and it will probably be worse than something maintained by a community of other developers). I don't want to build an HTTP webserver from scratch before I can develop my RESTful API. That is a domain where people have spent considerable amounts of time writing boiler plate and infrastructure code for you, why waste time writing it yourself. The same could said for many types of applications such as User Interfaces. I think you could say almost every code base is using some sort of library to help solve a problem that has already been solved.

As great as libraries and frameworks are, there is a catch. *The Pragmatic Programmer* discusses the concept of "wizard code" which the authors define as code that magically solves the problem you are attempting to solve or at least helps you solve that problem. I would classify most libraries and frameworks a form of wizard code. They solve a problem for you and you don't necessarily need to understand how they solve that problem for them to be useful. The problem with wizard code is that is does a lot for you and if you don't understand how it works it may be impossible to maintain an application built with wizard libraries or frameworks. If you don't have some idea how a specific library or framework your using is working, how could you be expected to add new features or maintain existing ones? I may not understand how a library works entirely but in *Soft Skills by John Sonmez* he mentions learning the 20% you need to be 80% effective with a technology. I find that to be a successful strategy with learning a new library or framework, you may never get to 100% proficiency but you will get close as you continue to work with the codebase.

The problem with libraries and frameworks is that we can end up treating them like black boxes. We give them some input like our data and they magically render our User Interface. What are we supposed to do if the UI doesn't quite look right or if it renders slowly? We seemingly have no control, it is just a black box to us. I used to take that approach when dealing with those sorts of problems, considering that all third party software *must* be perfect (it is not), the only possible outcome being that I am the one who is wrong. Don't be afraid to read third party source code. This will allow you to have a more maintainable codebase because you will be able to diagnosis issues as something that is definitely your source codes fault or something that is a problem with the library itself or more often how it is being used. Don't let the libraries or frameworks you and your team are using be "wizard code" instead you should strive to understand how the technology works under the hood.

### Design to Test
I am assuming that you have some familarity with software testing concepts such as unit testing and integration testing. In conjunction with that, I am going to assume you have already taken the plunge and believe that testing your code is generally the right thing to do in most scenarios. With those thoughts in mind I am looking to respond to the statement "...but my code is too hard to test!" not the reasoning behind why you should test in general. I would go as far as to say if code is hard to test it is potentially written poorly.

There are some things that are *actually* hard to test. If your code relies on network or file I/O it may be hard to test because you don't want to actually do network calls in a test environment, your tests should be able to run offline. Although, in my post about [focusing on functional purity](/focusing-on-functional-purity) I discuss how you can isolate and push I/O down into a single place that can be mocked to always do something good or bad depending on your test case. In conjunction with that, code that utilizes static methods is tricky to test at times because static methods can not easily be mocked. A trick I learned is to put static calls into a wrapper method on the class under test and then you can spy that method to change its behavior and essentially mock what it is returning. It is not a perfect strategy and I welcome ideas for better strategies but it works well when you are only using a few static method calls. Considering I/O and the usage of static method calls is going to allow you to be able to code to test and allow you to skip the phase where you need to refactor your code to make it testable. If your code is already written in a manner that makes it testable you are more likely to test it.

Classes that utilize composition of other classes can be tough to test. When you go to test the desired class you may quickly realize things are much more difficult than you had anticipated. The class has a method that calls a method on a different object which calls a method on a another object and so on. You don't really want to test that call chain for unit testing purposes, but how do you get around this? A test constructor is a constructor you only use for testing purposes to pass in mock (or spy) values for the objects that compose the class you would like to test. This allows you to define what should happen when other objects are interacted with, allowing you to focus on testing the class you had originally wanted to test instead of wrestling with all the pieces that class is composed of. 

When thinking of code that is not easily to test we may find ourselves considering just not testing it. Code that is designed to be tested will never be hard to test. Finding the balance between designing your software, implementing it, and designing it to be testable is the key. I have not mastered it myself but at least considering how things will be tested while I am writing my code has allowed my productivity to sky rocket. 

### Always Consider Orthogonality